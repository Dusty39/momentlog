rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // =============================================
    // HELPER FUNCTIONS
    // =============================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isPublicMoment() {
      return resource.data.isPublic == true;
    }
    
    function isFollower(authorId) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(authorId)).data.followers.hasAny([request.auth.uid]);
    }

    // Security Check: Ensure array modification only affects the current user's UID
    function onlyModifiesOwnIdInArray(arrayField) {
      let added = request.resource.data[arrayField].removeAll(resource.data[arrayField]);
      let removed = resource.data[arrayField].removeAll(request.resource.data[arrayField]);
      return (added.size() <= 1 && (added.size() == 0 || added.hasAll([request.auth.uid]))) &&
             (removed.size() <= 1 && (removed.size() == 0 || removed.hasAll([request.auth.uid])));
    }
    
    // =============================================
    // MOMENTS COLLECTION
    // =============================================
    match /moments/{momentId} {
      allow read: if isOwner(resource.data.userId) 
                  || (isPublicMoment() && (resource.data.isPrivateProfile != true || isFollower(resource.data.userId)));

      allow create: if isAuthenticated() 
                    && request.resource.data.userId == request.auth.uid;
      
      // Update protection: Only owner can edit content. 
      // Others can only toggle THEIR OWN LIKE, and ONLY if the moment is accessible.
      allow update: if isOwner(resource.data.userId) 
                    || (isAuthenticated() 
                        && (isPublicMoment() || isFollower(resource.data.userId) || isOwner(resource.data.userId))
                        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'commentsCount'])
                        && onlyModifiesOwnIdInArray('likes'));
      
      allow delete: if isOwner(resource.data.userId);
      
      match /comments/{commentId} {
        allow read: if get(/databases/$(database)/documents/moments/$(momentId)).data.isPublic == true
                    || isOwner(get(/databases/$(database)/documents/moments/$(momentId)).data.userId)
                    || isFollower(get(/databases/$(database)/documents/moments/$(momentId)).data.userId);
        
        allow create: if isAuthenticated()
                      && (get(/databases/$(database)/documents/moments/$(momentId)).data.isPublic == true || isFollower(get(/databases/$(database)/documents/moments/$(momentId)).data.userId))
                      && request.resource.data.userId == request.auth.uid;
        
        allow update: if isAuthenticated()
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes'])
                      && onlyModifiesOwnIdInArray('likes');
        
        allow delete: if isOwner(resource.data.userId)
                      || isOwner(get(/databases/$(database)/documents/moments/$(momentId)).data.userId);
      }
    }
    
    // =============================================
    // USERS COLLECTION
    // =============================================
    match /users/{userId} {
      allow read: if true;
      allow create: if isOwner(userId);
      
      // Update protection: Only owner can edit profile.
      // Others can only ADD/REMOVE THEMSELVES from the followers array (for following/unfollowing).
      allow update: if isOwner(userId) 
                    || (isAuthenticated() 
                        && request.resource.data.diff(resource.data).affectedKeys().hasAny(['followers', 'pendingFollowers'])
                        && onlyModifiesOwnIdInArray('followers') 
                        && (request.resource.data.pendingFollowers == resource.data.pendingFollowers || onlyModifiesOwnIdInArray('pendingFollowers')));
      
      allow delete: if isOwner(userId);

      match /private/config {
        allow read, write: if isOwner(userId);
      }
      
      match /followers/{followerId} {
        allow read: if isAuthenticated();
        allow create, delete: if isOwner(followerId);
      }
      
      match /following/{followingId} {
        allow read: if isAuthenticated();
        // Only owner can modify who they are following
        allow create, delete: if isOwner(userId) && isOwner(followingId);
      }
    }
    
    // =============================================
    // JOURNALS COLLECTION
    // =============================================
    match /journals/{journalId} {
      // Strictly owner only
      allow read, write: if isAuthenticated() && 
                           ((resource == null && request.resource.data.userId == request.auth.uid) || 
                            (resource != null && resource.data.userId == request.auth.uid));
    }
    
    // =============================================
    // NOTIFICATIONS COLLECTION
    // =============================================
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && (resource.data.targetUid == request.auth.uid || resource.data.userId == request.auth.uid);
      
      allow create: if isAuthenticated() 
                    && (request.resource.data.senderUid == request.auth.uid || request.resource.data.fromUid == request.auth.uid);
      
      allow update, delete: if isAuthenticated() && (resource.data.targetUid == request.auth.uid || resource.data.userId == request.auth.uid);
    }

    match /usernames/{username} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.uid == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.uid == request.auth.uid;
    }
  }
}
