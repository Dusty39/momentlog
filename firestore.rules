rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // =============================================
    // HELPER FUNCTIONS
    // =============================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isPublicMoment() {
      return resource.data.isPublic == true;
    }
    
    function isFollower(authorId) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(authorId)).data.followers.hasAny([request.auth.uid]);
    }

    function isFriend(authorId) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(authorId)).data.friends.hasAny([request.auth.uid]);
    }

    function isFriendsOnly() {
      return resource.data.visibility == 'friends' || resource.data.isFriendsOnly == true;
    }

    // Security Check: Ensure array modification only affects the current user's UID
    function onlyModifiesOwnIdInArray(arrayField) {
      let added = request.resource.data[arrayField].removeAll(resource.data[arrayField]);
      let removed = resource.data[arrayField].removeAll(request.resource.data[arrayField]);
      return (added.size() <= 1 && (added.size() == 0 || added.hasAll([request.auth.uid]))) &&
             (removed.size() <= 1 && (removed.size() == 0 || removed.hasAll([request.auth.uid])));
    }
    
    // Premium user check
    function isPremiumUser(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.isVerified == true || userDoc.data.isEarlyUser == true;
    }
    
    // Premium edit check (5-minute window)
    function canEditMoment() {
      let moment = resource.data;
      let timeDiff = request.time.toMillis() - moment.createdAt.toMillis();
      let fiveMinutes = 5 * 60 * 1000;
      let allowedFields = ['text', 'stickerText', 'musicText', 'musicUrl', 'theme', 'updatedAt'];
      
      return isOwner(moment.userId) 
             && isPremiumUser(request.auth.uid)
             && timeDiff < fiveMinutes
             && request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields)
             && isValidMoment(request.resource.data); // Validate new data
    }

    // --- DATA VALIDATION ---
    function isValidMoment(data) {
      let isPrem = isPremiumUser(request.auth.uid);
      let textLimit = isPrem ? 500 : 250;
      let photoLimit = isPrem ? 7 : 3;
      
      return (!('text' in data) || data.text.size() <= textLimit)
             && (!('media' in data) || data.media.size() <= photoLimit)
             && (!('stickerText' in data) || data.stickerText == null || data.stickerText.size() <= 50)
             && (!('musicText' in data) || data.musicText == null || data.musicText.size() <= 100)
             && (!('theme' in data) || data.theme in ['minimal', 'dark', 'vintage', 'love', 'nature', 'party']);
    }
    
    // =============================================
    // MOMENTS COLLECTION
    // =============================================
    match /moments/{momentId} {
      allow read: if isOwner(resource.data.userId) 
                  || (isPublicMoment() && (resource.data.isPrivateProfile != true || isFollower(resource.data.userId)))
                  || (isFriendsOnly() && isFollower(resource.data.userId));

      allow create: if isAuthenticated() 
                    && request.resource.data.userId == request.auth.uid
                    && isValidMoment(request.resource.data);
      
      // Update protection: 
      // 1. Time-sensitive edits (text, theme etc.) allowed for 5 mins for premium users
      // 2. OR Likes/CommentsCount updates by anyone (if public/follower)
      // 3. OR Owner can ALWAYS update visibility/privacy settings
      allow update: if canEditMoment()
                    || (isAuthenticated() 
                        && (isPublicMoment() || isFollower(resource.data.userId) || isOwner(resource.data.userId))
                        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'commentsCount'])
                        && onlyModifiesOwnIdInArray('likes'))
                    || (isOwner(resource.data.userId)
                        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isPublic', 'visibility', 'isFriendsOnly', 'isPrivateProfile']));
      
      allow delete: if isOwner(resource.data.userId);
      
      match /comments/{commentId} {
        allow read: if get(/databases/$(database)/documents/moments/$(momentId)).data.isPublic == true
                    || isOwner(get(/databases/$(database)/documents/moments/$(momentId)).data.userId)
                    || isFollower(get(/databases/$(database)/documents/moments/$(momentId)).data.userId);
        
        allow create: if isAuthenticated()
                      && (get(/databases/$(database)/documents/moments/$(momentId)).data.isPublic == true || isFollower(get(/databases/$(database)/documents/moments/$(momentId)).data.userId))
                      && request.resource.data.userId == request.auth.uid;
        
        allow update: if isAuthenticated()
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes'])
                      && onlyModifiesOwnIdInArray('likes');
        
        allow delete: if isOwner(resource.data.userId)
                      || isOwner(get(/databases/$(database)/documents/moments/$(momentId)).data.userId);
      }
    }
    
    // =============================================
    // USERS COLLECTION
    // =============================================
    match /users/{userId} {
      allow read: if true;
      allow create: if isOwner(userId);
      
      // Update protection: Only owner can edit profile.
      // Others can only ADD/REMOVE THEMSELVES from the followers array (for following/unfollowing).
      allow update: if isOwner(userId) 
                    || (isAuthenticated() 
                        && request.resource.data.diff(resource.data).affectedKeys().hasAny(['followers', 'pendingFollowers'])
                        && onlyModifiesOwnIdInArray('followers') 
                        && (request.resource.data.pendingFollowers == resource.data.pendingFollowers || onlyModifiesOwnIdInArray('pendingFollowers')));
      
      allow delete: if isOwner(userId);

      match /private/config {
        allow read, write: if isOwner(userId);
      }
      
      match /followers/{followerId} {
        allow read: if isAuthenticated();
        allow create, delete: if isOwner(followerId);
      }
      
      match /following/{followingId} {
        allow read: if isAuthenticated();
        // Only owner can modify who they are following
        allow create, delete: if isOwner(userId) && isOwner(followingId);
      }
    }
    
    // =============================================
    // JOURNALS COLLECTION
    // =============================================
    match /journals/{journalId} {
      // Separated rules to prevent crash on read (accessing request.resource)
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // =============================================
    // NOTIFICATIONS COLLECTION
    // =============================================
    // =============================================
    // REPORTS COLLECTION
    // =============================================
    match /reports/{reportId} {
      allow create: if isAuthenticated() && request.resource.data.reporterId == request.auth.uid;
      allow read, update, delete: if false; // Only admins (via backend) can read
    }

    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && (resource.data.targetUid == request.auth.uid || resource.data.userId == request.auth.uid);
      
      allow create: if isAuthenticated() 
                    && (request.resource.data.senderUid == request.auth.uid || request.resource.data.fromUid == request.auth.uid);
      
      allow update, delete: if isAuthenticated() && (resource.data.targetUid == request.auth.uid || resource.data.userId == request.auth.uid);
    }

    match /usernames/{username} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.uid == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.uid == request.auth.uid;
    }
  }
}
